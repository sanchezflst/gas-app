{"ast":null,"code":"import { SEC_TO_RAD } from '../constants/values';\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nexport var iterations = 1;\nexport function init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = z_im * this.a + this.x0;\n  p.y = z_re * this.a + this.y0;\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1E5;\n  var lon = this.long0 + d_lambda;\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["SEC_TO_RAD","iterations","init","A","B_re","B_im","C_re","C_im","D","forward","p","n","lon","x","lat","y","delta_lat","lat0","delta_lon","long0","d_phi","d_lambda","d_phi_n","d_psi","th_re","th_im","th_n_re","th_n_im","th_n_re1","th_n_im1","z_re","z_im","a","x0","y0","inverse","delta_x","delta_y","z_n_re","z_n_im","z_n_re1","z_n_im1","i","num_re","num_im","den_re","den_im","den2","d_psi_n","names"],"sources":["/home/chemy/final/node_modules/proj4/lib/projections/nzmg.js"],"sourcesContent":["import {SEC_TO_RAD} from '../constants/values';\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nexport var iterations = 1;\n\nexport function init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}