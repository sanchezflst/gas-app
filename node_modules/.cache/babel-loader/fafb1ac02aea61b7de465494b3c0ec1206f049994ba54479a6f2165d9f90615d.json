{"ast":null,"code":"import { PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_NODATUM, R2D, SRS_WGS84_ESQUARED, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR } from './constants/values';\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n  return point;\n}\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {\n    x: -point.x,\n    y: point.y\n  };\n  var output = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  outer: for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrids = grid.grid.subgrids;\n    for (var j = 0, jj = subgrids.length; j < jj; j++) {\n      var subgrid = subgrids[j];\n      // skip tables that don't match our point at all\n      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n      var minX = subgrid.ll[0] - epsilon;\n      var minY = subgrid.ll[1] - epsilon;\n      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n        continue;\n      }\n      output = applySubgridShift(input, inverse, subgrid);\n      if (!isNaN(output.x)) {\n        break outer;\n      }\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\" + -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  if (isNaN(pin.x)) {\n    return val;\n  }\n  var tb = {\n    x: pin.x,\n    y: pin.y\n  };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9,\n      tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {\n        x: tb.x - (del.x + t.x),\n        y: tb.y - (del.y + t.y)\n      };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\nfunction nadInterpolate(pin, ct) {\n  var t = {\n    x: pin.x / ct.del[0],\n    y: pin.y / ct.del[1]\n  };\n  var indx = {\n    x: Math.floor(t.x),\n    y: Math.floor(t.y)\n  };\n  var frct = {\n    x: t.x - 1.0 * indx.x,\n    y: t.y - 1.0 * indx.y\n  };\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = indx.y * ct.lim[0] + indx.x;\n  var f00 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx++;\n  var f10 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx += ct.lim[0];\n  var f11 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx--;\n  var f01 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  var m11 = frct.x * frct.y,\n    m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y),\n    m01 = (1.0 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}","map":{"version":3,"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_NODATUM","R2D","SRS_WGS84_ESQUARED","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","geodeticToGeocentric","geocentricToGeodetic","geocentricToWgs84","geocentricFromWgs84","compareDatums","adjust_lon","checkParams","type","source","dest","point","datum_type","source_a","a","source_es","es","gridShiftCode","applyGridShift","undefined","dest_a","dest_b","b","dest_es","datum_params","destGridShiftResult","inverse","grids","length","console","log","input","x","y","output","Number","NaN","onlyMandatoryGrids","attemptedGrids","outer","i","grid","push","name","isNull","mandatory","subgrids","j","jj","subgrid","epsilon","Math","abs","del","minX","ll","minY","maxX","lim","maxY","applySubgridShift","isNaN","pin","ct","val","tb","PI","t","nadInterpolate","tol","dif","indx","floor","frct","inx","f00","cvs","f10","f11","f01","m11","m10","m00","m01"],"sources":["/home/chemy/final/node_modules/proj4/lib/datum_transform.js"],"sourcesContent":["import {\n  PJD_3PARAM,\n  PJD_7PARAM,\n  PJD_GRIDSHIFT,\n  PJD_NODATUM,\n  R2D,\n  SRS_WGS84_ESQUARED,\n  SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR\n} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\n\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {x: -point.x, y: point.y};\n  var output = {x: Number.NaN, y: Number.NaN};\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  outer:\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrids = grid.grid.subgrids;\n    for (var j = 0, jj = subgrids.length; j < jj; j++) {\n      var subgrid = subgrids[j];\n      // skip tables that don't match our point at all\n      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n      var minX = subgrid.ll[0] - epsilon;\n      var minY = subgrid.ll[1] - epsilon;\n      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {\n        continue;\n      }\n      output = applySubgridShift(input, inverse, subgrid);\n      if (!isNaN(output.x)) {\n        break outer;\n      }\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\"+\n      -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {x: Number.NaN, y: Number.NaN};\n  if (isNaN(pin.x)) { return val; }\n  var tb = {x: pin.x, y: pin.y};\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};\n  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};\n  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};\n  var val= {x: Number.NaN, y: Number.NaN};\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx++;\n  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx += ct.lim[0];\n  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx--;\n  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}