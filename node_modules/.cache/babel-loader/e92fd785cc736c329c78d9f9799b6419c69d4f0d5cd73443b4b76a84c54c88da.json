{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport { EPSLN } from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n  p.x = x;\n  p.y = y;\n  return p;\n}\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));\n  if (lon < -Math.PI) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["adjust_lon","init","EPSLN","forward","p","lon","x","lat","y","delta_lon","long0","theta","con","Math","PI","sin","delta_theta","cos","abs","a","x0","y0","inverse","arg","asin","names"],"sources":["/home/chemy/final/node_modules/proj4/lib/projections/moll.js"],"sourcesContent":["import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport {EPSLN} from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,sBAAsB;AAC7C,OAAO,SAASC,IAAIA,CAAA,EAAG,CAAC;AACxB,SAAQC,KAAK,QAAO,qBAAqB;AACzC;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,CAAC,EAAE;EAEzB;AACF;EACE,IAAIC,GAAG,GAAGD,CAAC,CAACE,CAAC;EACb,IAAIC,GAAG,GAAGH,CAAC,CAACI,CAAC;EAEb,IAAIC,SAAS,GAAGT,UAAU,CAACK,GAAG,GAAG,IAAI,CAACK,KAAK,CAAC;EAC5C,IAAIC,KAAK,GAAGJ,GAAG;EACf,IAAIK,GAAG,GAAGC,IAAI,CAACC,EAAE,GAAGD,IAAI,CAACE,GAAG,CAACR,GAAG,CAAC;;EAEjC;AACF;EACE,OAAO,IAAI,EAAE;IACX,IAAIS,WAAW,GAAG,EAAEL,KAAK,GAAGE,IAAI,CAACE,GAAG,CAACJ,KAAK,CAAC,GAAGC,GAAG,CAAC,IAAI,CAAC,GAAGC,IAAI,CAACI,GAAG,CAACN,KAAK,CAAC,CAAC;IAC1EA,KAAK,IAAIK,WAAW;IACpB,IAAIH,IAAI,CAACK,GAAG,CAACF,WAAW,CAAC,GAAGd,KAAK,EAAE;MACjC;IACF;EACF;EACAS,KAAK,IAAI,CAAC;;EAEV;AACF;AACA;EACE,IAAIE,IAAI,CAACC,EAAE,GAAG,CAAC,GAAGD,IAAI,CAACK,GAAG,CAACX,GAAG,CAAC,GAAGL,KAAK,EAAE;IACvCO,SAAS,GAAG,CAAC;EACf;EACA,IAAIH,CAAC,GAAG,cAAc,GAAG,IAAI,CAACa,CAAC,GAAGV,SAAS,GAAGI,IAAI,CAACI,GAAG,CAACN,KAAK,CAAC,GAAG,IAAI,CAACS,EAAE;EACvE,IAAIZ,CAAC,GAAG,eAAe,GAAG,IAAI,CAACW,CAAC,GAAGN,IAAI,CAACE,GAAG,CAACJ,KAAK,CAAC,GAAG,IAAI,CAACU,EAAE;EAE5DjB,CAAC,CAACE,CAAC,GAAGA,CAAC;EACPF,CAAC,CAACI,CAAC,GAAGA,CAAC;EACP,OAAOJ,CAAC;AACV;AAEA,OAAO,SAASkB,OAAOA,CAAClB,CAAC,EAAE;EACzB,IAAIO,KAAK;EACT,IAAIY,GAAG;;EAEP;AACF;EACEnB,CAAC,CAACE,CAAC,IAAI,IAAI,CAACc,EAAE;EACdhB,CAAC,CAACI,CAAC,IAAI,IAAI,CAACa,EAAE;EACdE,GAAG,GAAGnB,CAAC,CAACI,CAAC,IAAI,eAAe,GAAG,IAAI,CAACW,CAAC,CAAC;;EAEtC;AACF;AACA;EACE,IAAIN,IAAI,CAACK,GAAG,CAACK,GAAG,CAAC,GAAG,cAAc,EAAE;IAClCA,GAAG,GAAG,cAAc;EACtB;EACAZ,KAAK,GAAGE,IAAI,CAACW,IAAI,CAACD,GAAG,CAAC;EACtB,IAAIlB,GAAG,GAAGL,UAAU,CAAC,IAAI,CAACU,KAAK,GAAIN,CAAC,CAACE,CAAC,IAAI,cAAc,GAAG,IAAI,CAACa,CAAC,GAAGN,IAAI,CAACI,GAAG,CAACN,KAAK,CAAC,CAAE,CAAC;EACtF,IAAIN,GAAG,GAAI,CAACQ,IAAI,CAACC,EAAG,EAAE;IACpBT,GAAG,GAAG,CAACQ,IAAI,CAACC,EAAE;EAChB;EACA,IAAIT,GAAG,GAAGQ,IAAI,CAACC,EAAE,EAAE;IACjBT,GAAG,GAAGQ,IAAI,CAACC,EAAE;EACf;EACAS,GAAG,GAAG,CAAC,CAAC,GAAGZ,KAAK,GAAGE,IAAI,CAACE,GAAG,CAAC,CAAC,GAAGJ,KAAK,CAAC,IAAIE,IAAI,CAACC,EAAE;EACjD,IAAID,IAAI,CAACK,GAAG,CAACK,GAAG,CAAC,GAAG,CAAC,EAAE;IACrBA,GAAG,GAAG,CAAC;EACT;EACA,IAAIhB,GAAG,GAAGM,IAAI,CAACW,IAAI,CAACD,GAAG,CAAC;EAExBnB,CAAC,CAACE,CAAC,GAAGD,GAAG;EACTD,CAAC,CAACI,CAAC,GAAGD,GAAG;EACT,OAAOH,CAAC;AACV;AAEA,OAAO,IAAIqB,KAAK,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC;AACxC,eAAe;EACbxB,IAAI,EAAEA,IAAI;EACVE,OAAO,EAAEA,OAAO;EAChBmB,OAAO,EAAEA,OAAO;EAChBG,KAAK,EAAEA;AACT,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}