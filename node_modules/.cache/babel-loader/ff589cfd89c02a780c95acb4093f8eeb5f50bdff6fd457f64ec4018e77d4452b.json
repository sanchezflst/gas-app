{"ast":null,"code":"import { D2R, R2D, PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT } from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\nfunction checkNotWGS(source, dest) {\n  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== 'WGS84';\n}\nexport default function transform(source, dest, point, enforceAxis) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  } else {\n    // Clone the point object so inputs don't get modified\n    point = {\n      x: point.x,\n      y: point.y,\n      z: point.z,\n      m: point.m\n    };\n  }\n  var hasZ = point.z !== undefined;\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point, enforceAxis);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (enforceAxis && source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else {\n    // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (enforceAxis && dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n  if (point && !hasZ) {\n    delete point.z;\n  }\n  return point;\n}","map":{"version":3,"names":["D2R","R2D","PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","datum_transform","adjust_axis","proj","toPoint","checkSanity","checkNotWGS","source","dest","datum","datum_type","datumCode","transform","point","enforceAxis","wgs84","Array","isArray","x","y","z","m","hasZ","undefined","axis","projName","to_meter","inverse","from_greenwich","forward"],"sources":["/home/chemy/final/node_modules/proj4/lib/transform.js"],"sourcesContent":["import {D2R, R2D, PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT} from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return (\n    (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== 'WGS84') ||\n    ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point, enforceAxis) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  } else {\n    // Clone the point object so inputs don't get modified\n    point = {\n      x: point.x,\n      y: point.y,\n      z: point.z,\n      m: point.m\n    };\n  }\n  var hasZ = point.z !== undefined;\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point, enforceAxis);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (enforceAxis && source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (enforceAxis && dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  if (point && !hasZ) {\n    delete point.z;\n  }\n  return point;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}