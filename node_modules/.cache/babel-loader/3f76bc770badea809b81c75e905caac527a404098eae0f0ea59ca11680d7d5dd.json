{"ast":null,"code":"// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport { EPSLN, TWO_PI, SPI, HALF_PI, FORTPI } from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n  FRONT: 1,\n  RIGHT: 2,\n  BACK: 3,\n  LEFT: 4,\n  TOP: 5,\n  BOTTOM: 6\n};\nvar AREA_ENUM = {\n  AREA_0: 1,\n  AREA_1: 2,\n  AREA_2: 3,\n  AREA_3: 4\n};\nexport function init() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {\n    x: 0,\n    y: 0\n  };\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {\n    value: 0\n  };\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    //if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = lon > 0.0 ? lon - SPI : lon + SPI;\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon > 0.0 ? -lon + SPI : -lon - SPI;\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {\n    lam: 0,\n    phi: 0\n  };\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {\n    value: 0\n  };\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = mu < 0.0 ? mu + SPI : mu - SPI;\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = SPI / 12 * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */{\n        lp.lam = theta;\n      }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */{\n        lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;\n      }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = lp.phi < 0 ? 1 : 0;\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = theta >= 0.0 ? theta - SPI : theta + SPI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["EPSLN","TWO_PI","SPI","HALF_PI","FORTPI","FACE_ENUM","FRONT","RIGHT","BACK","LEFT","TOP","BOTTOM","AREA_ENUM","AREA_0","AREA_1","AREA_2","AREA_3","init","x0","y0","lat0","long0","lat_ts","title","face","Math","abs","es","one_minus_f","a","b","one_minus_f_squared","forward","p","xy","x","y","lat","lon","theta","phi","t","mu","area","value","atan","tan","q","r","s","sinlat","coslat","sinlon","coslon","qsc_shift_lon_origin","sin","cos","acos","qsc_fwd_equat_face_theta","sqrt","inverse","lp","lam","nu","cosmu","tannu","tantheta","cosphi","atan2","invert_sign","tanphi","xa","offset","slon","names"],"sources":["/home/chemy/final/node_modules/proj4/lib/projections/qsc.js"],"sourcesContent":["// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport {EPSLN, TWO_PI, SPI, HALF_PI, FORTPI} from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}