{"ast":null,"code":"import msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport sign from '../common/sign';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport { HALF_PI, EPSLN } from '../constants/values';\nexport function init() {\n  //double lat0;                    /* the reference latitude               */\n  //double long0;                   /* the reference longitude              */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n\n  //the above value can be set with proj4.defs\n  //example: proj4.defs(\"EPSG:2154\",\"+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  } else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  } else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = this.rh - (p.y - this.y0) / this.k0;\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  } else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * x, con * y);\n  }\n  if (rh1 !== 0 || this.ns > 0) {\n    con = 1 / this.ns;\n    ts = Math.pow(rh1 / (this.a * this.f0), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  } else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_1SP\", \"Lambert_Conformal_Conic_2SP\", \"lcc\", \"Lambert Conic Conformal (1SP)\", \"Lambert Conic Conformal (2SP)\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["msfnz","tsfnz","sign","adjust_lon","phi2z","HALF_PI","EPSLN","init","lat2","lat1","k0","x0","y0","Math","abs","temp","b","a","e","sqrt","sin1","sin","cos1","cos","ms1","ts1","sin2","cos2","ms2","ts2","ts0","lat0","ns","log","isNaN","f0","pow","rh","title","forward","p","lon","x","lat","y","PI","con","ts","rh1","theta","long0","inverse","atan2","names"],"sources":["/home/chemy/final/node_modules/proj4/lib/projections/lcc.js"],"sourcesContent":["import msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport sign from '../common/sign';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport {HALF_PI, EPSLN} from '../constants/values';\nexport function init() {\n  \n  //double lat0;                    /* the reference latitude               */\n  //double long0;                   /* the reference longitude              */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n  \n  //the above value can be set with proj4.defs\n  //example: proj4.defs(\"EPSG:2154\",\"+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\n  \"Lambert Tangential Conformal Conic Projection\",\n  \"Lambert_Conformal_Conic\",\n  \"Lambert_Conformal_Conic_1SP\",\n  \"Lambert_Conformal_Conic_2SP\",\n  \"lcc\",\n  \"Lambert Conic Conformal (1SP)\",\n  \"Lambert Conic Conformal (2SP)\"\n];\n\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,iBAAiB;AACnC,OAAOC,KAAK,MAAM,iBAAiB;AACnC,OAAOC,IAAI,MAAM,gBAAgB;AACjC,OAAOC,UAAU,MAAM,sBAAsB;AAC7C,OAAOC,KAAK,MAAM,iBAAiB;AACnC,SAAQC,OAAO,EAAEC,KAAK,QAAO,qBAAqB;AAClD,OAAO,SAASC,IAAIA,CAAA,EAAG;EAErB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;;EAEA,IAAI,CAAC,IAAI,CAACC,IAAI,EAAE;IACd,IAAI,CAACA,IAAI,GAAG,IAAI,CAACC,IAAI;EACvB,CAAC,CAAC;EACF,IAAI,CAAC,IAAI,CAACC,EAAE,EAAE;IACZ,IAAI,CAACA,EAAE,GAAG,CAAC;EACb;EACA,IAAI,CAACC,EAAE,GAAG,IAAI,CAACA,EAAE,IAAI,CAAC;EACtB,IAAI,CAACC,EAAE,GAAG,IAAI,CAACA,EAAE,IAAI,CAAC;EACtB;EACA,IAAIC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACL,IAAI,GAAG,IAAI,CAACD,IAAI,CAAC,GAAGF,KAAK,EAAE;IAC3C;EACF;EAEA,IAAIS,IAAI,GAAG,IAAI,CAACC,CAAC,GAAG,IAAI,CAACC,CAAC;EAC1B,IAAI,CAACC,CAAC,GAAGL,IAAI,CAACM,IAAI,CAAC,CAAC,GAAGJ,IAAI,GAAGA,IAAI,CAAC;EAEnC,IAAIK,IAAI,GAAGP,IAAI,CAACQ,GAAG,CAAC,IAAI,CAACZ,IAAI,CAAC;EAC9B,IAAIa,IAAI,GAAGT,IAAI,CAACU,GAAG,CAAC,IAAI,CAACd,IAAI,CAAC;EAC9B,IAAIe,GAAG,GAAGxB,KAAK,CAAC,IAAI,CAACkB,CAAC,EAAEE,IAAI,EAAEE,IAAI,CAAC;EACnC,IAAIG,GAAG,GAAGxB,KAAK,CAAC,IAAI,CAACiB,CAAC,EAAE,IAAI,CAACT,IAAI,EAAEW,IAAI,CAAC;EAExC,IAAIM,IAAI,GAAGb,IAAI,CAACQ,GAAG,CAAC,IAAI,CAACb,IAAI,CAAC;EAC9B,IAAImB,IAAI,GAAGd,IAAI,CAACU,GAAG,CAAC,IAAI,CAACf,IAAI,CAAC;EAC9B,IAAIoB,GAAG,GAAG5B,KAAK,CAAC,IAAI,CAACkB,CAAC,EAAEQ,IAAI,EAAEC,IAAI,CAAC;EACnC,IAAIE,GAAG,GAAG5B,KAAK,CAAC,IAAI,CAACiB,CAAC,EAAE,IAAI,CAACV,IAAI,EAAEkB,IAAI,CAAC;EAExC,IAAII,GAAG,GAAG7B,KAAK,CAAC,IAAI,CAACiB,CAAC,EAAE,IAAI,CAACa,IAAI,EAAElB,IAAI,CAACQ,GAAG,CAAC,IAAI,CAACU,IAAI,CAAC,CAAC;EAEvD,IAAIlB,IAAI,CAACC,GAAG,CAAC,IAAI,CAACL,IAAI,GAAG,IAAI,CAACD,IAAI,CAAC,GAAGF,KAAK,EAAE;IAC3C,IAAI,CAAC0B,EAAE,GAAGnB,IAAI,CAACoB,GAAG,CAACT,GAAG,GAAGI,GAAG,CAAC,GAAGf,IAAI,CAACoB,GAAG,CAACR,GAAG,GAAGI,GAAG,CAAC;EACrD,CAAC,MACI;IACH,IAAI,CAACG,EAAE,GAAGZ,IAAI;EAChB;EACA,IAAIc,KAAK,CAAC,IAAI,CAACF,EAAE,CAAC,EAAE;IAClB,IAAI,CAACA,EAAE,GAAGZ,IAAI;EAChB;EACA,IAAI,CAACe,EAAE,GAAGX,GAAG,IAAI,IAAI,CAACQ,EAAE,GAAGnB,IAAI,CAACuB,GAAG,CAACX,GAAG,EAAE,IAAI,CAACO,EAAE,CAAC,CAAC;EAClD,IAAI,CAACK,EAAE,GAAG,IAAI,CAACpB,CAAC,GAAG,IAAI,CAACkB,EAAE,GAAGtB,IAAI,CAACuB,GAAG,CAACN,GAAG,EAAE,IAAI,CAACE,EAAE,CAAC;EACnD,IAAI,CAAC,IAAI,CAACM,KAAK,EAAE;IACf,IAAI,CAACA,KAAK,GAAG,yBAAyB;EACxC;AACF;;AAEA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,CAAC,EAAE;EAEzB,IAAIC,GAAG,GAAGD,CAAC,CAACE,CAAC;EACb,IAAIC,GAAG,GAAGH,CAAC,CAACI,CAAC;;EAEb;EACA,IAAI/B,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGD,IAAI,CAACC,GAAG,CAAC6B,GAAG,CAAC,GAAG9B,IAAI,CAACgC,EAAE,CAAC,IAAIvC,KAAK,EAAE;IAClDqC,GAAG,GAAGzC,IAAI,CAACyC,GAAG,CAAC,IAAItC,OAAO,GAAG,CAAC,GAAGC,KAAK,CAAC;EACzC;EAEA,IAAIwC,GAAG,GAAGjC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACC,GAAG,CAAC6B,GAAG,CAAC,GAAGtC,OAAO,CAAC;EAC3C,IAAI0C,EAAE,EAAEC,GAAG;EACX,IAAIF,GAAG,GAAGxC,KAAK,EAAE;IACfyC,EAAE,GAAG9C,KAAK,CAAC,IAAI,CAACiB,CAAC,EAAEyB,GAAG,EAAE9B,IAAI,CAACQ,GAAG,CAACsB,GAAG,CAAC,CAAC;IACtCK,GAAG,GAAG,IAAI,CAAC/B,CAAC,GAAG,IAAI,CAACkB,EAAE,GAAGtB,IAAI,CAACuB,GAAG,CAACW,EAAE,EAAE,IAAI,CAACf,EAAE,CAAC;EAChD,CAAC,MACI;IACHc,GAAG,GAAGH,GAAG,GAAG,IAAI,CAACX,EAAE;IACnB,IAAIc,GAAG,IAAI,CAAC,EAAE;MACZ,OAAO,IAAI;IACb;IACAE,GAAG,GAAG,CAAC;EACT;EACA,IAAIC,KAAK,GAAG,IAAI,CAACjB,EAAE,GAAG7B,UAAU,CAACsC,GAAG,GAAG,IAAI,CAACS,KAAK,CAAC;EAClDV,CAAC,CAACE,CAAC,GAAG,IAAI,CAAChC,EAAE,IAAIsC,GAAG,GAAGnC,IAAI,CAACQ,GAAG,CAAC4B,KAAK,CAAC,CAAC,GAAG,IAAI,CAACtC,EAAE;EACjD6B,CAAC,CAACI,CAAC,GAAG,IAAI,CAAClC,EAAE,IAAI,IAAI,CAAC2B,EAAE,GAAGW,GAAG,GAAGnC,IAAI,CAACU,GAAG,CAAC0B,KAAK,CAAC,CAAC,GAAG,IAAI,CAACrC,EAAE;EAE3D,OAAO4B,CAAC;AACV;;AAEA;AACA;AACA,OAAO,SAASW,OAAOA,CAACX,CAAC,EAAE;EAEzB,IAAIQ,GAAG,EAAEF,GAAG,EAAEC,EAAE;EAChB,IAAIJ,GAAG,EAAEF,GAAG;EACZ,IAAIC,CAAC,GAAG,CAACF,CAAC,CAACE,CAAC,GAAG,IAAI,CAAC/B,EAAE,IAAI,IAAI,CAACD,EAAE;EACjC,IAAIkC,CAAC,GAAI,IAAI,CAACP,EAAE,GAAG,CAACG,CAAC,CAACI,CAAC,GAAG,IAAI,CAAChC,EAAE,IAAI,IAAI,CAACF,EAAG;EAC7C,IAAI,IAAI,CAACsB,EAAE,GAAG,CAAC,EAAE;IACfgB,GAAG,GAAGnC,IAAI,CAACM,IAAI,CAACuB,CAAC,GAAGA,CAAC,GAAGE,CAAC,GAAGA,CAAC,CAAC;IAC9BE,GAAG,GAAG,CAAC;EACT,CAAC,MACI;IACHE,GAAG,GAAG,CAACnC,IAAI,CAACM,IAAI,CAACuB,CAAC,GAAGA,CAAC,GAAGE,CAAC,GAAGA,CAAC,CAAC;IAC/BE,GAAG,GAAG,CAAC,CAAC;EACV;EACA,IAAIG,KAAK,GAAG,CAAC;EACb,IAAID,GAAG,KAAK,CAAC,EAAE;IACbC,KAAK,GAAGpC,IAAI,CAACuC,KAAK,CAAEN,GAAG,GAAGJ,CAAC,EAAII,GAAG,GAAGF,CAAE,CAAC;EAC1C;EACA,IAAKI,GAAG,KAAK,CAAC,IAAM,IAAI,CAAChB,EAAE,GAAG,CAAE,EAAE;IAChCc,GAAG,GAAG,CAAC,GAAG,IAAI,CAACd,EAAE;IACjBe,EAAE,GAAGlC,IAAI,CAACuB,GAAG,CAAEY,GAAG,IAAI,IAAI,CAAC/B,CAAC,GAAG,IAAI,CAACkB,EAAE,CAAC,EAAGW,GAAG,CAAC;IAC9CH,GAAG,GAAGvC,KAAK,CAAC,IAAI,CAACc,CAAC,EAAE6B,EAAE,CAAC;IACvB,IAAIJ,GAAG,KAAK,CAAC,IAAI,EAAE;MACjB,OAAO,IAAI;IACb;EACF,CAAC,MACI;IACHA,GAAG,GAAG,CAACtC,OAAO;EAChB;EACAoC,GAAG,GAAGtC,UAAU,CAAC8C,KAAK,GAAG,IAAI,CAACjB,EAAE,GAAG,IAAI,CAACkB,KAAK,CAAC;EAE9CV,CAAC,CAACE,CAAC,GAAGD,GAAG;EACTD,CAAC,CAACI,CAAC,GAAGD,GAAG;EACT,OAAOH,CAAC;AACV;AAEA,OAAO,IAAIa,KAAK,GAAG,CACjB,+CAA+C,EAC/C,yBAAyB,EACzB,6BAA6B,EAC7B,6BAA6B,EAC7B,KAAK,EACL,+BAA+B,EAC/B,+BAA+B,CAChC;AAED,eAAe;EACb9C,IAAI,EAAEA,IAAI;EACVgC,OAAO,EAAEA,OAAO;EAChBY,OAAO,EAAEA,OAAO;EAChBE,KAAK,EAAEA;AACT,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}