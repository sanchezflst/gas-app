{"ast":null,"code":"'use strict';\n\nimport { PJD_3PARAM, PJD_7PARAM, HALF_PI } from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];\n  } else if (source.datum_type === PJD_7PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return {\n      x: -Infinity,\n      y: -Infinity,\n      z: p.z\n    };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return {\n      x: Infinity,\n      y: Infinity,\n      z: p.z\n    };\n  }\n  if (Longitude > Math.PI) {\n    Longitude -= 2 * Math.PI;\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: (Rn * (1 - es) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = genau * genau;\n  var maxiter = 30;\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  } while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}","map":{"version":3,"names":["PJD_3PARAM","PJD_7PARAM","HALF_PI","compareDatums","source","dest","datum_type","a","Math","abs","es","datum_params","geodeticToGeocentric","p","Longitude","x","Latitude","y","Height","z","Rn","Sin_Lat","Sin2_Lat","Cos_Lat","Infinity","PI","sin","cos","sqrt","geocentricToGeodetic","b","genau","genau2","maxiter","P","RR","CT","ST","RX","RK","RN","CPHI0","SPHI0","CPHI","SPHI","SDPHI","iter","X","Y","Z","atan2","atan","geocentricToWgs84","Dx_BF","Dy_BF","Dz_BF","Rx_BF","Ry_BF","Rz_BF","M_BF","geocentricFromWgs84","x_tmp","y_tmp","z_tmp"],"sources":["/home/chemy/final/node_modules/proj4/lib/datumUtils.js"],"sourcesContent":["'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > HALF_PI) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}